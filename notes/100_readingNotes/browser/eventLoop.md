# 浏览器中的页面循环系统

# 宏观架构（后面还要结合安全架构梳理浏览器模块责任划分）
* 渲染线程：每个渲染进程都有一个主线程，需要处理渲染（dom树构建，css样式计算），js执行，输入事件
* 消息队列和事件循环系统：调度任务，保证主线程在有条不紊的运转

# 事件循环架构
* 处理其他线程发送过来的任务：为了处理线程外部的任务，引入消息队列模型，其他线程可以将任务添加到消息 队列中，由主线程从消息队列中读取并执行任务（事件循环加消息队列的模型）。
* 处理其他进程发送过来的任务：渲染进程专门有一个IO线程用来接收其他进程传进来的消息，接收到消息之后， 会将这些消息组装成任务发送给渲染主线程，接下来就是主线程通过事件循环加消息队列的模式对任务进行消费。

## 事件循环如何退岀
当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？ Chrome是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量（keep_runing），在每次执行完一个任务时，判断是否有设置退出标志。

# 页面使用单线程的缺点

## 第一个问题是如何处理高优先级的任务

* 作为同步任务的话会影响执行效率；
* 作为异步队列的时候会影响实时性。

兼顾效率和实时性的解决方案：通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列， 在执行宏任务的过程中，如果DOM有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为DOM变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。

## 第二个是如何解决单个任务执行时长过久的问题

# 关于css3动画与js动画效率对比

部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。JavaScript都是在在圭线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣。

# 关于微任务队列细节
每个宏在务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微任务列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别

# 浏览器部分责任划分
* 脚本任务将会由v8模块所在的线程（js线程）执行；
* 界面渲染任务则会由webkit模块所在线程（渲染线程）执行；
* 而HTTP任务则会由网络进程中的网络线程执行。
* 我们都知道js的长时间执行会导致界面卡顿、js线程与渲染线程互斥，其本质是脚本任务作为current running task执行过长时间，渲染任务无法成为currrent running task导致。

# 浏览器事件循环调度算法
1. 调度算法综合很多的因素：队列的权重、队列内任务的等待时间、任务类型（宏/微）等；
2. User InteractionTask Queue这个queue比其他的queue有着更高的优先级。以便能够更流畅的响应界面交互；
3. 每次执行完一个宏任务之后，就会循环所有的微任务，并依次将他们执行完毕，直至微任务队列清空；
4. 任务有很多种，有脚本执行，还有界面渲染等。

关于当前运行中任务：事件循环中，有一个current running task的引用。它引用就是当前正在执行的任务。事实上浏览器的事件循环是有一个调度算法的。每次从众多的queue当中选取一个任务出队，妹后将current running task设置为这个任务。接下来通过js引擎的预编译（字节码）以及逐行解析，在执行栈当中产生了 Execution Context的堆栈。关于任务分类：一段js代码才是一个任务，而不是一行.js代码。所谓的“一段js代码才是一个任务”是什么意思呢？可以肯定的告诉你：一个script标签里的所有代码，它们组成了一个任务宏任务，多个script多个宏任务；一个onClick回调里的代码，它们也组成了一个宏任务；promise.then回调里的代码是一个微任务等等。
script标签中的代码通过类似addEventListener('click',callback)的方式，记录了一个事件：当click发生的时候，callback作为一个任务被推入到User InteractionTask Queue。

# 在标准中有哪些队列
User Interaction Task Queue
Timer Callback Task Queue
HTTP Callback Task Queue

# 事件循环釆用的是轮训那么为什么不会卡死呢
实际过程中采用系统级中断机制，也就是有事件时，线程才会被激活，没事件时，线程就会被挂起。本质上也是一个for死循环，只不过多了一个event_.Wait()让线程挂起，其他线程提交任务时，通过event_.Signal()再唤醒刚刚挂起的线程去执行相应的任务。

# 浏览器怎么实现setTimeout

在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表， 包括了定时器和Chromium内部一些需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

# 使用setTimeout的一些注意事项

1. 如果当前任务执行时间过久，会影响定时器任务的执行；
2. 如果.setTimeQut存在嵌套调用，那么系统会设置最短时间间隔为4毫秒；在Chrome中，定时器被嵌套调用5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于4毫秒，那么浏览器会将每次调用的 时间间隔设置为4毫秒；
3. 未激活的页面，setTimeout执行最小间隔是1000毫秒；
4. 延时执行时间有最大值，2147483647毫秒（大约24.8天）;
5. 使用setTimeout设置的回调函数中的this不符合直觉；

# 异步回调的种类
1. 第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。
2. 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的：微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

# 关于微任务及其执行时机
我们知道当JavaScript执行一段脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给V8引擎内部使用的，所以你是无法通过JavaScript直接访问的。也就是说每个宏任务都关联了一个微任务队列。那么接下来，我们就需要分析两个重要的时间点一一微任务产生的时机和执行微任务队列的时机。 通常情况下，在当前宏任务中的JavaScript快执行完成时，也就在JavaScript引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。 WHATWG把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外，还有其他的检查点，不过不是太重要，这里就不做介绍了。

# 监听DOM变化的演变
* 初期通过Mutation Event观察者模式解决监视DOM变化并及时作出响应的需求，这种模式采用的是回调的方式， 当DOM发生变化后，会立马触发对应的回调，这种方式属于同步的模式
* MutationObserver将响应函数改成异步调用，可以不用在每次DOM变化都触发异步调用，而是等多次DOM变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的DOM变化。

MutationObserver采用了〃异步+微任务〃的策略。
a). 通过异步操作解决了同步操作的性能问题；
b). 通过微任务解决了实时性的问题。

# 事件循环队列标准与实现的区别
在WHATWG规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO完成消息队列， 渲染任务队列，并且可以给这些消息队列排优先级。但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。一个是规范，一个是实现。关于第二个问题解释起来就比较复杂了，涉及到来了V8是怎么执行的了，专栏中的“全局执行上下文”我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了 “全局执行上下文”，要解释清楚这个问题还要牵涉到V8的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解Realm概念。
	
# Promise

---