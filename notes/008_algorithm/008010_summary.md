# 数据结构与算法总结

# linked list
缓存淘汰策略：
* FIFO
* 最少使用策略LFU
* 最近最少使用策略LRU
链表特点：
* 通过后继指针next连接的不连续内存块
* 支持查找、插入和删除操作
* 随机访问的时间复杂度是O(n)
* 插入和删除的时间复杂度是O(1)
链表类型：
* 单链表
* 双向链表
* 循环链表
* 双向循环链表
双向链表：
* 对于删除特定指针指向的节点这种操作会比较有优势，因为可以通过前驱指针直接获取前驱节点
* 在有序链表中查询某个节点也会比较有优势，可根据大小关系向前或者向后查找

LinkedHashMap使用双向链表实现

LRU淘汰算法实现：
* 维护一个有序单链表
* 如果有新数据被访问并存在于链表中，则将数据从原来位置挪动到头部
* 如果有新数据被访问不存在于链表中，则将新数据添加到链表头部，如果链表已满，则删除尾节点

# queue
队列特点：
* 操作受限的线性表结构
* 通过数组实现的是顺序队列，通过链表实现的是链式队列
* interface {
*   head: number,
*   tail: number,
*   enqueue(element: string): boolean,
*   dequeue(): string,
* }
* 入队出队时间复杂度都是O(1)
* 支持动态扩容队列的入队最好时间复杂度是O(1)，最差时间复杂度是O(n)，均摊时间复杂度是O(1)

循环队列：如果在tail === n时，会有数据搬移工作，这样入队操作性能会受影响，我们可以通过循环队列来解决这个问题。循环队列队空判定条件：head === tail，队满的判定条件：(tail + 1) % n === head。
阻塞队列：在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可以取，知道队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。
我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。
并发队列：线程安全的队列。

线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

# stack
栈特点：
* 操作受限的线性表结构
* 通过数组实现的是顺序栈，通过链表实现的是链式栈
* interface {
*   count: number,
*   push(element: string): void,
*   pop(): string,
* }
* 入栈出栈时间复杂度都是O(1)
* 支持动态扩容栈的入栈最好时间复杂度是O(1)，最差时间复杂度是O(n)，均摊时间复杂度是O(1)
栈应用：
* 函数调用保存函数执行上下文
* 双栈实现简单计算器
* 合法括号匹配
* 双栈实现浏览器的前进后退功能

# recursion
递归需要满足的三个条件：
1. 一个问题的解可以分解为几个子问题的解
2. 这个问题与分解之后的子问题，除了数据规模不通，求解思路完全一样
3. 存在递归终止条件
写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。

计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

递归代码要警惕堆栈溢出

递归代码要警惕重复计算
通过散列表存储计算过的结果
因为递归调用一次就会在内存栈中保存一次现场数据，所以分析空间复杂度的时候也要考虑这一部分开销

怎么将递归代码改写为非递归代码
因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈，出栈过程，这样任何递归代码都可以改写成看上去不是递归的形式。

# sort
