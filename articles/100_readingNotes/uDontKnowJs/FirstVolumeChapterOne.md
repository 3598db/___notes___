# 你不知道的JavaScript（上卷）

# 第一部分 作用域和闭包

## 第一章 作用域是什么

### 1.1 编译原理
JS源代码执行之前一般会经历三个步骤：
1. 分词/词法分析
2. 解析/语法分析
3. 代码生成

### 1.2 理解作用域
LHS查询与RHS查询：
RHS查询主要是查询某个变量的值，而LHS查询则是试图找到容器的变量本身，从而可以对其赋值。

### 1.3 作用域嵌套
当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域为止。

## 第二章 词法作用域

### 2.1 词法阶段
大部分标准语言编译器的第一个阶段叫做词法化。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。   
简单的说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况是这样的）。

**无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。**

词法作用域只会查找一级标识符，如果是对象的某个属性查找，会在找到变量之后，对象属性访问规则会接管属性访问。

### 2.2 词法欺骗
**eval**
**with**

## 第三章 函数作用域与块作用域

### 3.1 函数中的作用域
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数范围内使用和复用（事实上在嵌套的作用域中也可以使用）。

### 3.3 函数作用域
包装函数的声明以`(function...`而不仅是以`function...`开始。尽管这看上去并不是一个很明显的细节，但实际上确实非常重要的区别。函数会被当做函数表达式而不是一个标准的函数声明来处理。

**函数声明和函数表达式之间作重要的区别是他们的名称标识符将会绑定在何处。**

函数声明将会被绑定在所在作用域，包装函数将会被绑定在函数自身而不是函数作用域中。

#### 3.3.1 匿名和具名
匿名函数缺陷：
1. 调用堆栈中没有函数名会导致调试很困难；
2. 在一个事件绑定多个回调函数的情况下，如果需要解绑定某一个函数时，或者需要卸载事件时解绑自身；
3. 可读性/可维护性差

#### 立即执行函数表达式
**IIFE**

两种写法：
1. `(function(){...})();`
2. `(function(){...}());`

应用场景：
类似jQuery等类库为保证变量纯净，防止变量暴露，会采用这种方式。
```javascript
// undefined可以被覆盖，所以采用这种方式获取原生undefined
(function(global,undefined){})(window);
```

### 3.4 块作用域
表面上JavaScript并没有块级作用域。但仍然有部分语法可以实现。

#### 3.4.1 with
用with从对象中创建出的作用域仅在with声明中而非外部作用域有效。

#### 3.4.2 try/catch
ES3中规定`try/catch`的`catch`分句会创建一个块级作用域，其中声明的变量仅在`catch`内部有效。

关于`try/catch`模拟块级作用域的例子：
```javascript
try{throw 2;}catch(a){
  console.log(a); // 2
}
console.log(a); // ReferenceError
```
```javascript
try{throw undefined;}catch(a){
  a = 2;
  console.log(a); // 2
}
console.log(a); // ReferenceError
```

#### 3.4.3 let
1. `let`会创建块级作用域；
2. `let`不存在声明提升，也就是常说的会产生暂时性死区；

`let`循环会将声明变量绑定在每一次迭代中，类似于下面的行为：
```javascript
{
  let j;
  for (j = 0; j < 10; j ++) {
    let i = j;
    console.log(i);
  }
}
```

#### 3.4.4 const

## 第四章 提升
>函数作用域和块级作用域的行为是一样的。可以总结为：任何声明在某个作用域内的变量，都将附属于这个作用域。

### 4.2 编译器再度来袭
包括变量和函数在内的所有声明都会在任何代码被执行前首先处理。

函数声明会被提升但是函数表达式不会被提升。

### 4.3 函数优先
函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“**重复**”声明的代码中）是函数会首先被提升，然后才是变量。

## 第五章 作用域闭包

无论通过何种方式将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

如果一个函数在创建它的词法作用域之外执行，就会保持对当前词法作用域的引用，就会产生闭包。

本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当做第一级的值类型到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包。

#### 5.5.1 现代的模块机制
简单的模块化实现方案：
```javascript
var MyModules = (function Manager() {
  var modules = {};

  function define(name, deps, impl) {
    for (var i = 0; i < deps.length; i ++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl, deps);
  }

  function get(name) {
    return modules[name];
  }

  return {
    define: define,
    get: get;
  }
})();
```

# 第二部分 this与原型对象

## 第一章 关于this

### 1.1 为什么要使用this
this提供了一种更优雅的方式来隐式“传递”一个对象的引用，因此可以将API设计得更加简洁并且易于复用。

### 1.2 误解

#### 1.2.1 指向自身

### 1.2.2 它的作用域
this在任何情况下都不指向函数的词法作用域

### 1.3 this到底是什么
**this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。**   
当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里调用（调用栈）、函数的调用方式、传入的参数等信息。`this`就是这个记录的一个属性，会在函数的执行过程中用到。

## 第二章 this全面解析

### 2.1 调用位置

### 2.2 绑定规则

#### 2.2.1 默认绑定
1. 全局函数调用时应用了`this`的**默认绑定**，因此`this`指向全局对象；
2. 如果使用严格模式（strict mode），则不能将全局对象用于默认绑定，因此`this`会绑定到`undefined`。

#### 2.2.2 隐式绑定
当函数有引用有上下文对象时，**隐式绑定**规则会把函数调用中的`this`绑定到这个上下文对象。

##### 隐式丢失
一个最常见的`this`绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把`this`绑定到全局对象或者`undefined`上，取决于是否是严格模式。

这种问题常常出现在回调函数时，由于回调函数只会针对于函数本身，其实是一个不带任何修饰的函数调用英，因此应用了默认绑定。

#### 2.2.3 显式绑定
主要通过`call`、`apply`方式给方法**显式绑定**`this`，但是显式绑定任然无法解决之前丢失绑定的问题，主要是`call``apply`任然是一个函数同步调用，对于异步执行的函数没有办法对`this`做持久化存储。

1. 硬绑定

```javascript
// 简单的硬绑定polyfill
Function.prototype.bind = function () {
  const args = [].slice.call(arguments);
  const ctx = args.shift();
  const fn = this;
  return function () {
    return fn.apply(ctx, args);
  }
}

// es6
Function.prototype.bind = function (ctx, ...args) {
  const fn = this;
  return function () {
    return fn.apply(ctx, args);
  }
}
```
不难看出硬绑定就是通过闭包将当前的`this`保存下来，供函数异步调用使用。

2. API调用的“上下文”   
forEach() ???

#### 2.2.3 new绑定
使用`new`来调用foo(...)时，我们会构造一个新对象并把它绑定到foo(...)调用中的`this`上。`new`是最后一种可以影响函数调用时`this`绑定行为的方法，我们称之为`new`绑定。

### 2.3 优先级
new绑定 > 显式绑定 > 隐式绑定 > 默认绑定

### 2.4 绑定例外

#### 2.4.1 被忽略的this
对于显式绑定是一个参数不必要的时候最好使用`Object.create(null)`这种空对象而不是使用`null`，倘若代码中真的有`this`访问，不存在的**对象引用**不会产生问题，也不会对全局对象产生影响。如果使用`null`，会将`this`绑定到全局对象中，将会导致不可预计的后果（比如修改全局对象）。

#### 2.4.2 间接引用

#### 2.4.3 软绑定

### 2.5 this词法
箭头函数的绑定无法修改

## 第三章 对象

### 3.1 语法
主要两种声明方式：
* 字面量
* 构造函数

### 3.2 类型
* `string`
* `number`
* `boolean`
* `null`
* `undefined`
* `object`
* `symbol`

#### 内置对象

### 3.3 内容
需要强调的一点是，当我们说’内容‘时，似乎在暗示这些值实际上被存储在对象内部，但这只是它的表现形式。在引擎内部，这些值的存储方式是多种多样的，一般并不会存在容器对象内部。存储在对象容器内部的是这些属性的名称，它们就像指针（从技术角度来说就是引用）一样，指向这些值真正的存储位置。

对象属性两种访问方式：
1. 属性访问 - `.key`
2. 键访问 - `['key']`
主要区别是`.`操作符要求属性名满足标识符的命名规范，而`[".."]`语法可以接受任意UTF-8/Unicode字符作为属性名。

#### 3.3.1 可计算属性名
ES6增加了可计算属性名，可以在文字形式中使用`[]`包裹一个表达式来当做属性名。

#### 3.3.2 属性和方法
属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定`this`，就像我们刚才提到的）。

#### 3.3.3 数组
如果你试图向数组添加一个属性但是属性名’看起来‘像一个数字，那它会变成数组的数值下标（因此会修改数组的内容而不是添加一个属性）。

#### 3.3.4 复制对象
复制对象需要注意的一些地方：
1. 循环引用问题
2. 对于JSON安全（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构完全一样的对象）的对象来说，有一个巧妙的复制方法：
```javascript
var newObj = JSON.parse(JSON.stringify(someObj));
```
3. ES6中的`Object.assign`方法可以遍历一个或多个源对象的所有可枚举属的自有键并把它们复制到目标对象，最后返回目标对象。

#### 3.3.5 属性描述符
1. `Writable` -- 决定是否可以修改属性的值
2. `Configurable` -- 只要属性是可配置的，就可以使用defineProperty(...)方法来修改属性描述符   
   1. 把`configurable`修改成`false`是单向操作，无法撤销；
   2. 除了无法修改，`configurable:false`还会禁止删除这个属性。
3. `Enumerable` -- 这个描述符控制的是属性是否会出现在对象的属性枚举中

#### 3.3.6 不变性
1. 对象常量
结合`writable:false`和`configurable:false`就可以创建一个真正的常量属性（不可修改、重定义或者删除）
2. 禁止扩展
如果你想禁止一个对象添加新属性并且保留已有属性，可以使用`Object.preventExtensions(...)`
3. 密封
`Object.seal(...)`会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用`Object.preventExtensions(...)`并把所有现有属性标记为`configurable:false`。
4. 冻结
`Object.freeze(...)`会创建一个冻结对象，这个方法实际上会在一个现有对象上调用`Object.seal(...)`并把所有“数据访问”属性标记为`writable:false`，这样就无法修改他们的值。

#### 3.3.7 [[Get]]
1. 对象默认的内置`[[GET]]`操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值；
2. 如果没有找到名称相同的属性，按照`[[GET]]`算法的定义会执行另外一种非常重要的行为（遍历原型链）；
3. 如果无论如何都没有找到名称相同的属性，那`[[GET]]`操作会返回值`undefined`。

#### 3.3.8 [[Put]]
1. 属性是否是访问描述符？如果是并且存在`setter`就调用`setter`；
2. 属性的数据描述符中`writable`是否是`false`？如果是，在非严格模式下静默失败，在严格模式下抛出`TypeError`异常；
3. 如果都不是，将该值设置为属性的值。

#### 3.3.9 Getter和Setter
当你给一个属性定义`getter`、`setter`或者两者都有时，这个属性会被定义为“访问描述符”（和“数据描述符”相对）。对于访问描述符来说，JavaScript会忽略他们的`value`和`writable`特性，取而代之的是关心set和get（还有`configurable`和`enumerable`）特性；

#### 3.3.10 存在性
问题：如果`obj.a`属性访问值返回的是`undefined`，但这个值有可能是属性中存储的`undefined`，也有可能是因为属性不存在所以返回的`undefined`。如何区分这两种情况。

1. `in`操作符会检查属性是否在对象及其`[[Prototype]]`原型链中，`hasOwnProperty(...)`会检查属性是否是自身属性；
2. 对于对象自身及其原型上没有原型链上，没有`hasOwnProperty`方法的（`Object.create(null)`），可以使用`Object.prototype.hasOwnProperty.call(obj, 'a')`；
3. 看起来新操作符可以检查容器内是否有某个值，但他实际上是检查某个属性名是否存在，这个对于数组要格外注意，例如`4 in [2, 4, 6] // false`，因为数组中的属性名是`0, 1, 2`；
4. `Object.prototypeIsEnumerable(...)`会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足`enumerable:true`；
5. `Object.keys(...)`会返回一个数组，包含所有可枚举属性；`Object.getOwnPropertyNames(...)`会返回一个数组，包含所有属性，无论是否可枚举。这两个方法都只会查找对象自身。

### 3.4 遍历
主要是是关于for...of循环和Iterator接口的问题，后面专题细说。

## 第四章 混合对象"类"

### 4.1 类理论
类/继承描述了一种代码的组织结构形式

面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然，不同的数据有不同的行为），因此好的设计就是把数据以及和它相关的行为打包（或者说封装）起来。这在正式的计算机科学中有时被称为数据结构。

#### 4.1.1 “类”设计模式

#### 4.1.2 JavaScript中的“类”

### 4.2 类的机制

#### 4.2.1 建造
类通过复制操作被实例化为对象形式

#### 4.2.2 构造函数
类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数，通过`new`调用产生一个实例。

### 4.3 类的继承
在面向对象的语言中，你可以先定义一个类，然后定义一个继承前者的类。

#### 4.3.1 多态
多态是一个非常广泛的话题，我们现在所说的“相对”只是多态的一个方面：任何方法都可以引用继承中高层的方法（无论高层的方法名和当前方法名是否相同）。   
多态的另一方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时会自动选择合适的定义。

#### 4.3.2 多重继承

### 4.4 混入

#### 4.4.1 显式混入

#### 4.4.2 隐式混入

**总的来说，这章质量不高，总结的维度深入也不够，感觉是作者并不认同在JavaScript中模拟类这种做法。**

## 第五章 原型

### 5.1 [[Prototype]]

JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。

1. [[Get]]操作会查找原型链；
2. in操作符会查找原型链（可枚举）

### 5.1.1 Object.prototype

所有的**普通**的[[Prototype]]链最终都会指向内置的Object.prototype。

先复习一下Object对象原型方法
```javascript
// Google Chrome(version 74.0.3729.169)
{
  constructor: 'ƒ Object()',
  hasOwnProperty: 'ƒ hasOwnProperty()',
  isPrototypeOf: 'ƒ isPrototypeOf()',
  propertyIsEnumerable: 'ƒ propertyIsEnumerable()',
  toLocaleString: 'ƒ toLocaleString()',
  toString: 'ƒ toString()',
  valueOf: 'ƒ valueOf()',
  __defineGetter__: 'ƒ __defineGetter__()',
  __defineSetter__: 'ƒ __defineSetter__()',
  __lookupGetter__: 'ƒ __lookupGetter__()',
  __lookupSetter__: 'ƒ __lookupSetter__()',
  get __proto__: 'ƒ __proto__()',
  set __proto__: 'ƒ __proto__()', 
}
```

#### 5.1.2 属性设置和屏蔽
```javascript
myObject.foo = 'bar';
```
如果给一个对象设置属性，如果该属性不存在于对象本身，那么就会去遍历[[Prototype]]链，如果既存在于自身又存在于[[Prototype]]链上，那么就会产生屏蔽现象。

屏蔽的三种情况：
1. 如果在[[Prototype]]链上层存在名为foo的普通数据访问类型并且没有被标记为只读，那就会直接在myObject对象中添加一个名为foo的新属性，它是屏蔽属性；
2. 如果在[[Prototype]]链上层存在foo，但是它被标记为只读，那么无法修改已有属性或者在myObject上创建屏蔽属性。如果在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。
3. 如果在[[Prototype]]链上存在foo并且它是一个setter，那就一定会调用这个
setter。foo不会被添加到myObject，也不会重新定义foo这个setter。

如果你希望第二第三种情况下也屏蔽foo，那就不能使用=操作符来赋值，而是使用Object.defineProperty(...)来向myObejct添加foo。

一些情况下会出现隐式屏蔽，比方说：
```javascript
myObject.foo++
```

### 5.2 “类”

#### 5.2.1 “类”函数
“模拟类”的行为利用了函数的一种特殊特性：所有的函数默认都会拥有一个名为prototype的公有并且不可枚举的属性，它会指向另一个对象。通过用new操作符实例化后的每个对象将最终被[[Prototype]]链接到这个“Foo.prototype”对象。
```javascript
function Foo() {};
Foo.prototype; // {}

var foo = new Foo();
Object.getPrototypeOf(foo) === Foo.prototype; // true
```

在面向对象语言中，类可以被复制（或者说实例化）多次，就像模具制作东西一样。但是在JavaScript中，并没有蕾丝的复制机制。你不能创建一个类的多个实例，只能创建多个对象，他们的[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，他们是互相关联的。

**委托**这个术语可以更加准确的描述JavaScript中对象的关联机制。

还有个偶尔会用到的JavaScript术语叫差异继承。如果你把JavaScript中对象的所有委托行为都归结到对象本身并且把对象看作是实物的话，那就（差不多）可以理解差异继承了。

但是和原型继承一样，差异继承会更多是你脑中构建出的模型，而非真实情况。它忽略了一个事实，那就是对象B实际上并不是被差异构造出来的，我们只是定义了B的一些指定特性，其他没有定义的东西都变成了“洞”。而这些洞（或者说缺少定义的空白处）最终会被委托行为“填满”。

#### 5.2.2 “构造函数”




















